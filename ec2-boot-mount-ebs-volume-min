#!/usr/bin/env python
import os
import sys
import time
import re
import logging
import logging.handlers
import subprocess
import argparse
import collections
def run_command(command,allowed_return_codes=[0]):
 process=subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
 stdout,stderr=process.communicate()
 if process.returncode in allowed_return_codes:
  return process.returncode,stdout
 else:
  logging.error('%s failed',' '.join(command))
  logging.error('%s',stderr)
  sys.exit(1)
def get_nvme_devices():
 return list(map(lambda p:'/dev/{}'.format(p),filter(lambda p:re.match(r'^nvme[0-9]+n1$',p),os.listdir('/dev/'))))
def get_nvme_block_device_mappings():
 return{'/dev/{}'.format(run_command(['ebsnvme-id','--udev',dev])[1].strip()):dev for dev in get_nvme_devices()}
def get_real_device(device):
 return device if os.path.exists(device)and not os.path.islink(device)else get_nvme_block_device_mappings().get(device)
def wait_for_device(device):
 real_device=get_real_device(device)
 while not(real_device and os.path.exists(real_device)):
  if real_device:
   logging.info('waiting for %s (%s) to appear',real_device,device)
  else:
   logging.info('waiting for %s to appear',device)
  time.sleep(5)
def is_device_formatted(device):
 return_code,_=run_command(["blkid",device],[0,2])
 return return_code==0
def conditional_format_device(entry,label):
 if not is_device_formatted(entry.device):
  logging.info('formatting %s',entry.device)
  _,output=run_command(['mkfs','-L',label,'-t',entry.fstype,entry.device])
  logging.info('%s',output)
 else:
  logging.info('%s  is already formatted',entry.device)
MountEntry=collections.namedtuple('MountEntry','device, mount_point, fstype, options, dump, fsck_pass')
def read_mounts(path='/proc/mounts'):
 fspattern=re.compile(r'^(?P<device>[^\s]+)\s+(?P<mount_point>[^\s]+)\s+(?P<fstype>[^\s]+)\s+(?P<options>[^\s]+)\s*(?P<dump>[^\s]+)?\s*(?P<fsck_pass>[^\s]+)?\s*$',re.MULTILINE)
 with open(path,'r')as f:
  return list(map(lambda l:MountEntry(**l.groupdict()),fspattern.finditer(f.read())))
def mount(entry):
 mounts=read_mounts('/proc/mounts')
 mounted=filter(lambda m:m.device==entry.device and m.mount_point==entry.mount_point,mounts)
 if not mounted:
  if filter(lambda m:m.mount_point==entry.mount_point,mounts):
   logging.error('mount point %s is already in use',entry.mount_point)
   sys.exit(1)
  if not os.path.exists(entry.mount_point):
   logging.info('creating mount point %s',entry.mount_point)
   run_command(['mkdir','-p',entry.mount_point])
  logging.info('mounting %s',entry.mount_point)
  run_command(["mount",'-t',entry.fstype,'-o',entry.options,entry.device,entry.mount_point])
 else:
  logging.info('device %s already mounted on %s',entry.device,entry.mount_point)
def mount_ebs_volume(entry,label):
 wait_for_device(entry.device)
 entry=MountEntry(get_real_device(entry.device),entry.mount_point,entry.fstype,entry.options,entry.dump,entry.fsck_pass)
 conditional_format_device(entry,label)
 mount(entry)
if __name__=='__main__':
 logging.basicConfig(format='%(levelname)s: %(message)s',level='INFO')
 if os.path.exists('/dev/log'):
  logging.getLogger().addHandler(logging.handlers.SysLogHandler(address='/dev/log'))
 parser=argparse.ArgumentParser(description='mount an EBS Volume on boot',formatter_class=argparse.RawDescriptionHelpFormatter)
 parser.add_argument('--device',dest='device',required=True,help='to mount')
 parser.add_argument('--directory',dest='directory',required=True,help='to mount onto')
 parser.add_argument('--fstype',dest='fstype',required=True,help='of the device')
 parser.add_argument('--options',dest='options',required=True,help='used in the mount')
 parser.add_argument('--label',dest='label',help='to assign to the disk')
 args=parser.parse_args()
 entry=MountEntry(args.device,args.directory,args.fstype,args.options,0,0)
 mount_ebs_volume(entry,args.label if args.label else args.device)
# Created by pyminifier (https://github.com/liftoff/pyminifier)

